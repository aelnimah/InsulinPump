// ===== File: Profile.h =====
#ifndef PROFILE_H
#define PROFILE_H

#include <string>
#include <vector>


class BasalSegment;

/*
 * Profile
 * -------
 * This class represents a personal insulin-delivery profile which includes settings such as:
 * - Basal segments (time-based insulin delivery rates)
 * - Insulin-to-carb ratio
 * - Correction factor
 * - Target blood glucose
 *
 * This class is critical for the "Manage Personal Profiles (CRUD)" use case.
 */
class Profile {
private:
    std::string name;
    std::vector<BasalSegment*> basalSegments;
    double insulinToCarbRatio;
    double correctionFactor;
    double targetBG;

public:
    Profile();
    ~Profile();

    // Check if the profile settings are valid.
    bool isValid() const;
    // Retrieve the basal rate for a given time.
    double getBasalRateForTime(double hour) const;

    // Getters and setters.
    std::string getName() const;
    void setName(const std::string &n);
    double getInsulinToCarbRatio() const;
    void setInsulinToCarbRatio(double ratio);
    double getCorrectionFactor() const;
    void setCorrectionFactor(double factor);
    double getTargetBG() const;
    void setTargetBG(double bg);
    std::vector<BasalSegment*> getBasalSegments() const;
    // Add a basal segment to the profile.
    void addBasalSegment(BasalSegment* segment);
};

#endif // PROFILE_H

// ===== File: Profile.cpp =====
#include "Profile.h"
#include "BasalSegment.h"

Profile::Profile() : insulinToCarbRatio(0.0), correctionFactor(0.0), targetBG(0.0) {}
Profile::~Profile() {
    for (auto segment : basalSegments)
        delete segment;
    basalSegments.clear();
}

bool Profile::isValid() const {
    if (name.empty() || insulinToCarbRatio <= 0 || correctionFactor <= 0 || targetBG <= 0)
        return false;
    for (const auto& seg : basalSegments) {
        if (seg->getStartTime() >= seg->getEndTime() || seg->getUnitsPerHour() < 0)
            return false;
    }
    return true;
}

double Profile::getBasalRateForTime(double hour) const {
    for (auto segment : basalSegments) {
        if (segment->timeInSegment(hour))
            return segment->getUnitsPerHour();
    }
    return 0.0;
}

std::string Profile::getName() const { return name; }
void Profile::setName(const std::string &n) { name = n; }
double Profile::getInsulinToCarbRatio() const { return insulinToCarbRatio; }
void Profile::setInsulinToCarbRatio(double ratio) { insulinToCarbRatio = ratio; }
double Profile::getCorrectionFactor() const { return correctionFactor; }
void Profile::setCorrectionFactor(double factor) { correctionFactor = factor; }
double Profile::getTargetBG() const { return targetBG; }
void Profile::setTargetBG(double bg) { targetBG = bg; }
std::vector<BasalSegment*> Profile::getBasalSegments() const { return basalSegments; }
void Profile::addBasalSegment(BasalSegment* segment) { basalSegments.push_back(segment); }


// ===== File: ProfileManager.h =====
#ifndef PROFILEMANAGER_H
#define PROFILEMANAGER_H

#include <string>
#include <vector>

class Profile;
class DBManager;

/*
 * ProfileManager
 * --------------
 * This class manages personal insulin-delivery profiles (CRUD operations).
 * It supports the "Manage Personal Profiles (CRUD)" use case where the user
 * can create, view, update, and delete profiles.
 */
class ProfileManager {
private:
    std::vector<Profile*> profiles;
    Profile* activeProfile;
    DBManager* dbManager;

public:
    ProfileManager();
    ~ProfileManager();

    // Create a new profile.
    void createProfile(Profile* newProfile);
    // Retrieve a profile by name.
    Profile* getProfileByName(const std::string &name);
    // Update an existing profile.
    void updateProfile(Profile* updatedProfile);
    // Delete a profile by name.
    void deleteProfile(const std::string &name);
    // Get the active profile.
    Profile* getActiveProfile();
    // Set the active profile by name.
    void setActiveProfile(const std::string &profileName);
    // Load profiles from the database.
    void loadProfilesFromDB();
    // Save profiles to the database.
    void saveProfilesToDB();

    // Getters and setters for DBManager.
    DBManager* getDBManager() const;
    void setDBManager(DBManager* db);
};

#endif // PROFILEMANAGER_H

// ===== File: ProfileManager.cpp =====
#include "ProfileManager.h"
#include "Profile.h"
#include <algorithm>
#include <iostream>

ProfileManager::ProfileManager() : activeProfile(nullptr), dbManager(nullptr) {}
ProfileManager::~ProfileManager() {
    for (auto profile : profiles)
        delete profile;
    profiles.clear();
}

void ProfileManager::createProfile(Profile* newProfile) {
    if (newProfile && newProfile->isValid()) {
        profiles.push_back(newProfile);
        std::cout << "Profile '" << newProfile->getName() << "' created.\n";
    }
}

Profile* ProfileManager::getProfileByName(const std::string &name) {
    for (auto profile : profiles) {
        if (profile->getName() == name)
            return profile;
    }
    return nullptr;
}

void ProfileManager::updateProfile(Profile* updatedProfile) {
    for (size_t i = 0; i < profiles.size(); ++i) {
        if (profiles[i]->getName() == updatedProfile->getName()) {
            delete profiles[i];
            profiles[i] = updatedProfile;
            std::cout << "Profile '" << updatedProfile->getName() << "' updated.\n";
            return;
        }
    }
}

void ProfileManager::deleteProfile(const std::string &name) {
    auto it = std::remove_if(profiles.begin(), profiles.end(), [&](Profile* p) {
        if (p->getName() == name) {
            delete p;
            std::cout << "Profile '" << name << "' deleted.\n";
            return true;
        }
        return false;
    });
    profiles.erase(it, profiles.end());
}

Profile* ProfileManager::getActiveProfile() { return activeProfile; }
void ProfileManager::setActiveProfile(const std::string &profileName) {
    activeProfile = getProfileByName(profileName);
    if (activeProfile) std::cout << "Active profile set to '" << profileName << "'.\n";
}
void ProfileManager::loadProfilesFromDB() {}
void ProfileManager::saveProfilesToDB() {}
DBManager* ProfileManager::getDBManager() const { return dbManager; }
void ProfileManager::setDBManager(DBManager* db) { dbManager = db; }


// ===== File: PumpSimulator.h =====
#ifndef PUMPSIMULATOR_H
#define PUMPSIMULATOR_H

#include <string>

class UIManager;
class InsulinDeliveryManager;
class BolusCalculator;
class ProfileManager;
class DataLogger;
class AlertManager;
class ControlIQController;
class Battery;
class Cartridge;

/*
 * PumpSimulator
 * --------------
 * This class acts as the main controller of the simulation. It uses
 * UIManager, BolusCalculator, InsulinDeliveryManager, ProfileManager, DataLogger,
 * AlertManager, ControlIQController, Battery, Cartridge, and DBManager.
 *
 * Use Cases Supported:
 * - Starting, stopping, and updating the simulation.
 * - Handling user input.
 * - Coordinating system-wide events (e.g., profile updates, bolus delivery).
 */
class PumpSimulator {
private:
    bool isRunning;
    UIManager* uiManager;
    InsulinDeliveryManager* deliveryManager;
    BolusCalculator* bolusCalculator;
    ProfileManager* profileManager;
    DataLogger* dataLogger;
    AlertManager* alertManager;
    ControlIQController* controlIQ;
    Battery* battery;
    Cartridge* cartridge;

public:
    // Constructor & Destructor.
    PumpSimulator();
    ~PumpSimulator();

    // Start the pump simulation.
    void startSimulation();
    // Stop the pump simulation.
    void stopSimulation();
    // Update the simulation state (e.g., sensor updates, IOB calculations).
    void updateSimulationState();
    // Handle user input commands.
    void handleUserInput(const std::string &input);
    // Shutdown the pump simulation.
    void shutdown();

    // Getters and setters.
    bool getIsRunning() const;
    void setIsRunning(bool running);

    // (Additional getters/setters for component pointers can be added as needed.)
    void setProfileManager(ProfileManager* mgr) { profileManager = mgr; }
    void setBolusCalculator(BolusCalculator* bc) { bolusCalculator = bc; }
    void setInsulinDeliveryManager(InsulinDeliveryManager* idm) { deliveryManager = idm; }
    void setControlIQController(ControlIQController* controller) { controlIQ = controller; }
};


#endif // PUMPSIMULATOR_H

// ===== File: PumpSimulator.cpp =====
#include "PumpSimulator.h"
#include "UIManager.h"
#include "InsulinDeliveryManager.h"
#include "BolusCalculator.h"
#include "ProfileManager.h"
#include "DataLogger.h"
#include "AlertManager.h"
#include "ControlIQController.h"
#include "Battery.h"
#include "Cartridge.h"
#include "CGMSensorInterface.h"
#include "Profile.h"
#include "BasalSegment.h"

#include <iostream>
#include <sstream>
#include <vector>
#include <thread>
#include <chrono>

PumpSimulator::PumpSimulator()
    : isRunning(false),
      uiManager(nullptr),
      deliveryManager(nullptr),
      bolusCalculator(nullptr),
      profileManager(nullptr),
      dataLogger(nullptr),
      alertManager(nullptr),
      controlIQ(nullptr),
      battery(nullptr),
      cartridge(nullptr)
{
}

PumpSimulator::~PumpSimulator() {}

void PumpSimulator::startSimulation() {
    isRunning = true;
    std::cout << "[PumpSimulator] Simulation started.\n";
}

void PumpSimulator::stopSimulation() {
    isRunning = false;
    std::cout << "[PumpSimulator] Simulation stopped.\n";
}

void PumpSimulator::updateSimulationState() {
    if (deliveryManager != nullptr) {
        deliveryManager->onTick(1.0);
    }
}


void PumpSimulator::handleUserInput(const std::string &input) {
    std::istringstream iss(input);
    std::string command;
    iss >> command;

    if (command == "create") {
        if (!profileManager) {
            std::cout << "[PumpSimulator] [Error] No ProfileManager available.\n";
            return;
        }
        std::string name;
        double icRatio = 0, corrFactor = 0, tbg = 0;
        iss >> name >> icRatio >> corrFactor >> tbg;
        if (name.empty() || icRatio <= 0 || corrFactor <= 0 || tbg <= 0) {
            std::cout << "[PumpSimulator] Usage: create <profileName> <ICRatio> <CorrFactor> <TargetBG>\n";
            return;
        }
        Profile* p = new Profile();
        p->setName(name);
        p->setInsulinToCarbRatio(icRatio);
        p->setCorrectionFactor(corrFactor);
        p->setTargetBG(tbg);
        BasalSegment* seg = new BasalSegment();
        seg->setStartTime(0.0);
        seg->setEndTime(24.0);
        seg->setUnitsPerHour(1.0);
        p->addBasalSegment(seg);
        profileManager->createProfile(p);
    }
    else if (command == "read") {
        if (!profileManager) {
            std::cout << "[PumpSimulator] [Error] No ProfileManager available.\n";
            return;
        }
        std::string name;
        iss >> name;
        if (name.empty()) {
            std::cout << "[PumpSimulator] Usage: read <profileName>\n";
            return;
        }
        Profile* found = profileManager->getProfileByName(name);
        if (!found) {
            std::cout << "[PumpSimulator] [Info] Profile '" << name << "' not found.\n";
        } else {
            std::cout << "[PumpSimulator] [Profile Info]\n";
            std::cout << "  Name: " << found->getName() << "\n";
            std::cout << "  I:C ratio = " << found->getInsulinToCarbRatio() << "\n";
            std::cout << "  CorrectionFactor = " << found->getCorrectionFactor() << "\n";
            std::cout << "  TargetBG = " << found->getTargetBG() << "\n";
            auto segments = found->getBasalSegments();
            std::cout << "  BasalSegments count = " << segments.size() << "\n";
        }
    }
    else if (command == "update") {
        if (!profileManager) {
            std::cout << "[PumpSimulator] [Error] No ProfileManager available.\n";
            return;
        }
        std::string name;
        double icRatio = 0, corrFactor = 0, tbg = 0;
        iss >> name >> icRatio >> corrFactor >> tbg;
        if (name.empty() || icRatio <= 0 || corrFactor <= 0 || tbg <= 0) {
            std::cout << "[PumpSimulator] Usage: update <profileName> <ICRatio> <CorrFactor> <TargetBG>\n";
            return;
        }
        Profile* updated = new Profile();
        updated->setName(name);
        updated->setInsulinToCarbRatio(icRatio);
        updated->setCorrectionFactor(corrFactor);
        updated->setTargetBG(tbg);
        BasalSegment* seg = new BasalSegment();
        seg->setStartTime(0.0);
        seg->setEndTime(24.0);
        seg->setUnitsPerHour(1.25);
        updated->addBasalSegment(seg);
        profileManager->updateProfile(updated);
    }
    else if (command == "delete") {
        if (!profileManager) {
            std::cout << "[PumpSimulator] [Error] No ProfileManager available.\n";
            return;
        }
        std::string name;
        iss >> name;
        if (name.empty()) {
            std::cout << "[PumpSimulator] Usage: delete <profileName>\n";
            return;
        }
        profileManager->deleteProfile(name);
    }
    else if (command == "setactive") {
        if (!profileManager) {
            std::cout << "[PumpSimulator] [Error] No ProfileManager available.\n";
            return;
        }
        std::string name;
        iss >> name;
        if (name.empty()) {
            std::cout << "[PumpSimulator] Usage: setactive <profileName>\n";
            return;
        }
        profileManager->setActiveProfile(name);
    }
    else if (command == "bolus") {
        if (!bolusCalculator || !deliveryManager || !profileManager) {
            std::cout << "[PumpSimulator] [Error] Missing BolusCalculator, InsulinDeliveryManager, or ProfileManager.\n";
            return;
        }
        Profile* activeProf = profileManager->getActiveProfile();
        if (!activeProf) {
            std::cout << "[PumpSimulator] [Error] No active profile set. Please create one and set it active.\n";
            return;
        }
        double currentBG = 0.0, carbIntake = 0.0;
        std::string mode;
        double duration = 0.0;
        iss >> currentBG >> carbIntake >> mode;
        if (currentBG <= 0 || carbIntake < 0) {
            std::cout << "[PumpSimulator] Usage: bolus <bg> <carbs> [immediate|extended <hours>] [override <units>]\n";
            return;
        }
        bool isExtended = false;
        if (mode == "extended") {
            isExtended = true;
            if (!(iss >> duration) || duration <= 0) {
                std::cout << "[PumpSimulator] [Error] Must specify a valid duration for extended bolus.\n";
                return;
            }
        }
        else if (mode.empty() || mode == "immediate") {
            isExtended = false;
            duration = 0.0;
        }
        else {
            std::cout << "[PumpSimulator] [Warning] Unrecognized mode '" << mode << "' => defaulting to immediate.\n";
            isExtended = false;
            duration = 0.0;
            iss.clear();
        }
        double iob = deliveryManager->getInsulinOnBoard();
        double recommendedDose = bolusCalculator->calculateBolus(currentBG, carbIntake, iob, activeProf);
        std::cout << "[PumpSimulator] Recommended bolus = " << recommendedDose << " units.\n";
        std::string maybeOverride;
        if (iss >> maybeOverride && maybeOverride == "override") {
            double overrideDose = 0.0;
            if (iss >> overrideDose && overrideDose >= 0.0) {
                recommendedDose = overrideDose;
                std::cout << "[PumpSimulator] Overriding recommended dose, using " << overrideDose << " units.\n";
            } else {
                std::cout << "[PumpSimulator] [Error] Invalid override dose. Ignoring override.\n";
            }
        }
        deliveryManager->deliverBolus(recommendedDose, isExtended, duration);
    }
    else if (command == "basal") {
            std::string action;
            iss >> action;
            if (action == "start") {
                double rate = 0.0;
                if (!(iss >> rate) || rate <= 0.0) {
                    std::cout << "[PumpSimulator] [Error] Usage: basal start <rate>\n";
                    return;
                }
                if (deliveryManager)
                    deliveryManager->startBasalDelivery(rate);
            } else if (action == "stop") {
                if (deliveryManager)
                    deliveryManager->stopBasalDelivery();
            } else if (action == "resume") {
                if (deliveryManager)
                    deliveryManager->resumeBasalDelivery();
            } else {
                std::cout << "[PumpSimulator] [Error] Unrecognized basal action: " << action << "\n";
            }
    }
    else if (command == "setbg") {
        double newBG = 0.0;
        if (!(iss >> newBG)) {
            std::cout << "[PumpSimulator] Usage: setbg <value>\n";
            return;
        }
        if (controlIQ && controlIQ->getCGMSensor()) {
            controlIQ->getCGMSensor()->setBG(newBG);
            std::cout << "[PumpSimulator] CGM sensor BG set to " << newBG << " mmol/L.\n";
        } else {
            std::cout << "[PumpSimulator] [Error] CGM sensor not available in Control IQ.\n";
        }
    }
    else if (command == "stop") {
        stopSimulation();
    }
    else if (command == "quit") {
        shutdown();
    }
    else if (command == "controliq") {
        if (!controlIQ) {
            std::cout << "[PumpSimulator] [Error] Control IQ Controller not available.\n";
            return;
        }
        if (!controlIQ->getIsActive()) {
            std::cout << "[PumpSimulator] [Info] Control IQ is not active. No automatic adjustments will be applied.\n";
            return;
        }
        double currentBG = controlIQ->getCGMSensor()->getCurrentBG();
        std::cout << "[PumpSimulator] Current BG from CGM sensor: " << currentBG << " mmol/L\n";

        controlIQ->processSensorReading(currentBG);
        controlIQ->predictBGTrend();

        controlIQ->applyAutomaticAdjustments();
    }
    else {
        std::cout << "[PumpSimulator] Unrecognized command: " << command << "\n";
        std::cout << "Commands:\n";
        std::cout << "  create <name> <ICRatio> <CorrFactor> <TargetBG>\n";
        std::cout << "  read <name>\n";
        std::cout << "  update <name> <ICRatio> <CorrFactor> <TargetBG>\n";
        std::cout << "  delete <name>\n";
        std::cout << "  setactive <profileName>\n";
        std::cout << "  bolus <bg> <carbs> [immediate|extended <hours>] [override <units>]\n";
        std::cout << "  basal <start|stop|resume> [<rate>]\n"; // NEW
        std::cout << "  stop\n";
        std::cout << "  quit\n";
    }
}

void PumpSimulator::shutdown() {
    std::cout << "[PumpSimulator] Shutting down.\n";
    stopSimulation();
}

bool PumpSimulator::getIsRunning() const {
    return isRunning;
}

void PumpSimulator::setIsRunning(bool running) {
    isRunning = running;
}

// ===== File: BasalSegment.h =====
#include "PumpSimulator.h"
#include "UIManager.h"
#include "InsulinDeliveryManager.h"
#include "BolusCalculator.h"
#include "ProfileManager.h"
#include "DataLogger.h"
#include "AlertManager.h"
#include "ControlIQController.h"
#include "Battery.h"
#include "Cartridge.h"
#include "CGMSensorInterface.h"
#include "Profile.h"
#include "BasalSegment.h"

#include <iostream>
#include <sstream>
#include <vector>
#include <thread>
#include <chrono>

PumpSimulator::PumpSimulator()
    : isRunning(false),
      uiManager(nullptr),
      deliveryManager(nullptr),
      bolusCalculator(nullptr),
      profileManager(nullptr),
      dataLogger(nullptr),
      alertManager(nullptr),
      controlIQ(nullptr),
      battery(nullptr),
      cartridge(nullptr)
{
}

PumpSimulator::~PumpSimulator() {}

void PumpSimulator::startSimulation() {
    isRunning = true;
    std::cout << "[PumpSimulator] Simulation started.\n";
}

void PumpSimulator::stopSimulation() {
    isRunning = false;
    std::cout << "[PumpSimulator] Simulation stopped.\n";
}

void PumpSimulator::updateSimulationState() {
    if (deliveryManager != nullptr) {
        deliveryManager->onTick(1.0);
    }
}


void PumpSimulator::handleUserInput(const std::string &input) {
    std::istringstream iss(input);
    std::string command;
    iss >> command;

    if (command == "create") {
        if (!profileManager) {
            std::cout << "[PumpSimulator] [Error] No ProfileManager available.\n";
            return;
        }
        std::string name;
        double icRatio = 0, corrFactor = 0, tbg = 0;
        iss >> name >> icRatio >> corrFactor >> tbg;
        if (name.empty() || icRatio <= 0 || corrFactor <= 0 || tbg <= 0) {
            std::cout << "[PumpSimulator] Usage: create <profileName> <ICRatio> <CorrFactor> <TargetBG>\n";
            return;
        }
        Profile* p = new Profile();
        p->setName(name);
        p->setInsulinToCarbRatio(icRatio);
        p->setCorrectionFactor(corrFactor);
        p->setTargetBG(tbg);
        BasalSegment* seg = new BasalSegment();
        seg->setStartTime(0.0);
        seg->setEndTime(24.0);
        seg->setUnitsPerHour(1.0);
        p->addBasalSegment(seg);
        profileManager->createProfile(p);
    }
    else if (command == "read") {
        if (!profileManager) {
            std::cout << "[PumpSimulator] [Error] No ProfileManager available.\n";
            return;
        }
        std::string name;
        iss >> name;
        if (name.empty()) {
            std::cout << "[PumpSimulator] Usage: read <profileName>\n";
            return;
        }
        Profile* found = profileManager->getProfileByName(name);
        if (!found) {
            std::cout << "[PumpSimulator] [Info] Profile '" << name << "' not found.\n";
        } else {
            std::cout << "[PumpSimulator] [Profile Info]\n";
            std::cout << "  Name: " << found->getName() << "\n";
            std::cout << "  I:C ratio = " << found->getInsulinToCarbRatio() << "\n";
            std::cout << "  CorrectionFactor = " << found->getCorrectionFactor() << "\n";
            std::cout << "  TargetBG = " << found->getTargetBG() << "\n";
            auto segments = found->getBasalSegments();
            std::cout << "  BasalSegments count = " << segments.size() << "\n";
        }
    }
    else if (command == "update") {
        if (!profileManager) {
            std::cout << "[PumpSimulator] [Error] No ProfileManager available.\n";
            return;
        }
        std::string name;
        double icRatio = 0, corrFactor = 0, tbg = 0;
        iss >> name >> icRatio >> corrFactor >> tbg;
        if (name.empty() || icRatio <= 0 || corrFactor <= 0 || tbg <= 0) {
            std::cout << "[PumpSimulator] Usage: update <profileName> <ICRatio> <CorrFactor> <TargetBG>\n";
            return;
        }
        Profile* updated = new Profile();
        updated->setName(name);
        updated->setInsulinToCarbRatio(icRatio);
        updated->setCorrectionFactor(corrFactor);
        updated->setTargetBG(tbg);
        BasalSegment* seg = new BasalSegment();
        seg->setStartTime(0.0);
        seg->setEndTime(24.0);
        seg->setUnitsPerHour(1.25);
        updated->addBasalSegment(seg);
        profileManager->updateProfile(updated);
    }
    else if (command == "delete") {
        if (!profileManager) {
            std::cout << "[PumpSimulator] [Error] No ProfileManager available.\n";
            return;
        }
        std::string name;
        iss >> name;
        if (name.empty()) {
            std::cout << "[PumpSimulator] Usage: delete <profileName>\n";
            return;
        }
        profileManager->deleteProfile(name);
    }
    else if (command == "setactive") {
        if (!profileManager) {
            std::cout << "[PumpSimulator] [Error] No ProfileManager available.\n";
            return;
        }
        std::string name;
        iss >> name;
        if (name.empty()) {
            std::cout << "[PumpSimulator] Usage: setactive <profileName>\n";
            return;
        }
        profileManager->setActiveProfile(name);
    }
    else if (command == "bolus") {
        if (!bolusCalculator || !deliveryManager || !profileManager) {
            std::cout << "[PumpSimulator] [Error] Missing BolusCalculator, InsulinDeliveryManager, or ProfileManager.\n";
            return;
        }
        Profile* activeProf = profileManager->getActiveProfile();
        if (!activeProf) {
            std::cout << "[PumpSimulator] [Error] No active profile set. Please create one and set it active.\n";
            return;
        }
        double currentBG = 0.0, carbIntake = 0.0;
        std::string mode;
        double duration = 0.0;
        iss >> currentBG >> carbIntake >> mode;
        if (currentBG <= 0 || carbIntake < 0) {
            std::cout << "[PumpSimulator] Usage: bolus <bg> <carbs> [immediate|extended <hours>] [override <units>]\n";
            return;
        }
        bool isExtended = false;
        if (mode == "extended") {
            isExtended = true;
            if (!(iss >> duration) || duration <= 0) {
                std::cout << "[PumpSimulator] [Error] Must specify a valid duration for extended bolus.\n";
                return;
            }
        }
        else if (mode.empty() || mode == "immediate") {
            isExtended = false;
            duration = 0.0;
        }
        else {
            std::cout << "[PumpSimulator] [Warning] Unrecognized mode '" << mode << "' => defaulting to immediate.\n";
            isExtended = false;
            duration = 0.0;
            iss.clear();
        }
        double iob = deliveryManager->getInsulinOnBoard();
        double recommendedDose = bolusCalculator->calculateBolus(currentBG, carbIntake, iob, activeProf);
        std::cout << "[PumpSimulator] Recommended bolus = " << recommendedDose << " units.\n";
        std::string maybeOverride;
        if (iss >> maybeOverride && maybeOverride == "override") {
            double overrideDose = 0.0;
            if (iss >> overrideDose && overrideDose >= 0.0) {
                recommendedDose = overrideDose;
                std::cout << "[PumpSimulator] Overriding recommended dose, using " << overrideDose << " units.\n";
            } else {
                std::cout << "[PumpSimulator] [Error] Invalid override dose. Ignoring override.\n";
            }
        }
        deliveryManager->deliverBolus(recommendedDose, isExtended, duration);
    }
    else if (command == "basal") {
            std::string action;
            iss >> action;
            if (action == "start") {
                double rate = 0.0;
                if (!(iss >> rate) || rate <= 0.0) {
                    std::cout << "[PumpSimulator] [Error] Usage: basal start <rate>\n";
                    return;
                }
                if (deliveryManager)
                    deliveryManager->startBasalDelivery(rate);
            } else if (action == "stop") {
                if (deliveryManager)
                    deliveryManager->stopBasalDelivery();
            } else if (action == "resume") {
                if (deliveryManager)
                    deliveryManager->resumeBasalDelivery();
            } else {
                std::cout << "[PumpSimulator] [Error] Unrecognized basal action: " << action << "\n";
            }
    }
    else if (command == "setbg") {
        double newBG = 0.0;
        if (!(iss >> newBG)) {
            std::cout << "[PumpSimulator] Usage: setbg <value>\n";
            return;
        }
        if (controlIQ && controlIQ->getCGMSensor()) {
            controlIQ->getCGMSensor()->setBG(newBG);
            std::cout << "[PumpSimulator] CGM sensor BG set to " << newBG << " mmol/L.\n";
        } else {
            std::cout << "[PumpSimulator] [Error] CGM sensor not available in Control IQ.\n";
        }
    }
    else if (command == "stop") {
        stopSimulation();
    }
    else if (command == "quit") {
        shutdown();
    }
    else if (command == "controliq") {
        if (!controlIQ) {
            std::cout << "[PumpSimulator] [Error] Control IQ Controller not available.\n";
            return;
        }
        if (!controlIQ->getIsActive()) {
            std::cout << "[PumpSimulator] [Info] Control IQ is not active. No automatic adjustments will be applied.\n";
            return;
        }
        double currentBG = controlIQ->getCGMSensor()->getCurrentBG();
        std::cout << "[PumpSimulator] Current BG from CGM sensor: " << currentBG << " mmol/L\n";

        controlIQ->processSensorReading(currentBG);
        controlIQ->predictBGTrend();

        controlIQ->applyAutomaticAdjustments();
    }
    else {
        std::cout << "[PumpSimulator] Unrecognized command: " << command << "\n";
        std::cout << "Commands:\n";
        std::cout << "  create <name> <ICRatio> <CorrFactor> <TargetBG>\n";
        std::cout << "  read <name>\n";
        std::cout << "  update <name> <ICRatio> <CorrFactor> <TargetBG>\n";
        std::cout << "  delete <name>\n";
        std::cout << "  setactive <profileName>\n";
        std::cout << "  bolus <bg> <carbs> [immediate|extended <hours>] [override <units>]\n";
        std::cout << "  basal <start|stop|resume> [<rate>]\n"; // NEW
        std::cout << "  stop\n";
        std::cout << "  quit\n";
    }
}

void PumpSimulator::shutdown() {
    std::cout << "[PumpSimulator] Shutting down.\n";
    stopSimulation();
}

bool PumpSimulator::getIsRunning() const {
    return isRunning;
}

void PumpSimulator::setIsRunning(bool running) {
    isRunning = running;
}

// ===== File: BasalSegment.cpp =====
#include "BasalSegment.h"

BasalSegment::BasalSegment() : startTime(0.0), endTime(0.0), unitsPerHour(0.0) {}
BasalSegment::~BasalSegment() {}

bool BasalSegment::timeInSegment(double hour) const {
    return (hour >= startTime && hour < endTime);
}

double BasalSegment::getStartTime() const { return startTime; }
void BasalSegment::setStartTime(double start) { startTime = start; }
double BasalSegment::getEndTime() const { return endTime; }
void BasalSegment::setEndTime(double end) { endTime = end; }
double BasalSegment::getUnitsPerHour() const { return unitsPerHour; }
void BasalSegment::setUnitsPerHour(double units) { unitsPerHour = units; }

// ===== File: MainWindow.h =====
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; }
QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private:
    Ui::MainWindow *ui;
};
#endif // MAINWINDOW_H

// ===== File: MainWindow.cpp =====
#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}

// ===== File: BolusCalculator.h =====
#ifndef BOLUSCALCULATOR_H
#define BOLUSCALCULATOR_H

#include <cmath>

class Profile;

/*
 * BolusCalculator
 * ---------------
 * This class calculates the recommended insulin bolus dose based on inputs such as
 * current blood glucose, carbohydrate intake, and insulin on board. It supports the
 * "Deliver Manual Bolus" use case.
 */

class BolusCalculator {
public:
    BolusCalculator();
    ~BolusCalculator();

    // Calculate the recommended bolus dose.
    double calculateBolus(double currentBG, double carbIntake, double iob, Profile* profile);
    // Calculate the split amount for an extended bolus.
    double calculateExtendedBolusSplit(double totalBolus, double fraction);
    // Calculate a correction bolus based on blood glucose deviation.
    double calculateCorrectionBolus(double currentBG, double targetBG, double correctionFactor);
};

#endif // BOLUSCALCULATOR_H

// ===== File: BolusCalculator.cpp =====
#include "BolusCalculator.h"
#include "Profile.h"
#include <cmath>

BolusCalculator::BolusCalculator() {}
BolusCalculator::~BolusCalculator() {}

double BolusCalculator::calculateBolus(double currentBG, double carbIntake, double iob, Profile* profile) {
    double carbBolus = carbIntake / profile->getInsulinToCarbRatio();
    double correctionBolus = calculateCorrectionBolus(currentBG, profile->getTargetBG(), profile->getCorrectionFactor());
    return std::round(carbBolus - correctionBolus);
}

double BolusCalculator::calculateExtendedBolusSplit(double totalBolus, double fraction) {
    return std::round(totalBolus / fraction);
}

double BolusCalculator::calculateCorrectionBolus(double currentBG, double targetBG, double correctionFactor) {
    return (currentBG - targetBG) / correctionFactor;
}

// ===== File: Battery.h =====
#ifndef BATTERY_H
#define BATTERY_H

/*
 * Battery
 * -------
 * This class represents the pump's battery.
 * It provides methods for updating battery level, charging, and checking if the battery is low.
 *
 * Use Cases Supported:
 * - Displaying battery status on the home screen.
 * - Triggering alerts if battery levels are critical.
 */
class Battery {
private:
    int level;
    bool isCharging;
    double drainRate;

public:
    Battery();
    ~Battery();

    // Update the battery level based on elapsed time.
    void updateBattery(double elapsedTime);
    // Charge the battery.
    void chargeBattery();
    // Check if the battery level is low.
    bool isLow() const;

    // Getters and setters.
    int getLevel() const;
    void setLevel(int lvl);
    bool getIsCharging() const;
    void setIsCharging(bool charging);
    double getDrainRate() const;
    void setDrainRate(double rate);
};

#endif // BATTERY_H

// ===== File: Battery.cpp =====
#include "BolusCalculator.h"
#include "Profile.h"
#include <cmath>

BolusCalculator::BolusCalculator() {}
BolusCalculator::~BolusCalculator() {}

double BolusCalculator::calculateBolus(double currentBG, double carbIntake, double iob, Profile* profile) {
    double carbBolus = carbIntake / profile->getInsulinToCarbRatio();
    double correctionBolus = calculateCorrectionBolus(currentBG, profile->getTargetBG(), profile->getCorrectionFactor());
    return std::round(carbBolus - correctionBolus);
}

double BolusCalculator::calculateExtendedBolusSplit(double totalBolus, double fraction) {
    return std::round(totalBolus / fraction);
}

double BolusCalculator::calculateCorrectionBolus(double currentBG, double targetBG, double correctionFactor) {
    return (currentBG - targetBG) / correctionFactor;
}

// ===== File: Cartridge.h =====
#ifndef CARTRIDGE_H
#define CARTRIDGE_H

/*
 * Cartridge
 * ---------
 * This class represents the insulin cartridge.
 * It provides methods to use insulin, check the current volume, and refill the cartridge.
 *
 * Use Cases Supported:
 * - Alerting the user if the insulin volume is too low.
 * - Managing insulin usage during bolus or basal delivery.
 */
class Cartridge {
private:
    double capacity;
    double currentVolume;

public:
    Cartridge();
    ~Cartridge();

    // Attempt to use a specified amount of insulin.
    bool useInsulin(double amount);
    // Refill the cartridge to full capacity.
    void refill();
    // Check if the cartridge is low on insulin.
    bool isLow() const;

    // Getters and setters.
    double getCapacity() const;
    void setCapacity(double cap);
    double getCurrentVolume() const;
    void setCurrentVolume(double vol);
};

#endif // CARTRIDGE_H

// ===== File: Cartridge.cpp =====
#include "Cartridge.h"

Cartridge::Cartridge() : capacity(200.0), currentVolume(200.0) {}
Cartridge::~Cartridge() {}

bool Cartridge::useInsulin(double amount) {
    if(currentVolume >= amount) {
        currentVolume -= amount;
        return true;
    }
    return false;
}
void Cartridge::refill() { currentVolume = capacity; }
bool Cartridge::isLow() const { return currentVolume < (capacity * 0.1); }
double Cartridge::getCapacity() const { return capacity; }
void Cartridge::setCapacity(double cap) { capacity = cap; }
double Cartridge::getCurrentVolume() const { return currentVolume; }
void Cartridge::setCurrentVolume(double vol) { currentVolume = vol; }

// ===== File: CGMSensorInterface.h =====
#ifndef CGMSENSORINTERFACE_H
#define CGMSENSORINTERFACE_H

class Profile;

/*
 * CGMSensorInterface
 * ------------------
 * This class simulates a Continuous Glucose Monitor (CGM) sensor.
 * It provides the current blood glucose (BG) value and can simulate the next reading.
 *
 * Use Cases Supported:
 * - Feeding CGM data to ControlIQController for automatic insulin adjustments.
 */
class CGMSensorInterface {
private:
    Profile* profile;
    double currentBG;
    bool isActive;

public:
    CGMSensorInterface();
    ~CGMSensorInterface();

    // Get the current blood glucose reading.
    double getCurrentBG() const;
    // Simulate the next sensor reading.
    void simulateNextReading();
    // Set a new blood glucose value.
    void setBG(double newValue);
};

#endif // CGMSENSORINTERFACE_H


// ===== File: CGMSensorInterface.cpp =====
#include "CGMSensorInterface.h"
#include "Profile.h"

CGMSensorInterface::CGMSensorInterface() : currentBG(0.0), profile(nullptr) {}
CGMSensorInterface::~CGMSensorInterface() {}

double CGMSensorInterface::getCurrentBG() const { return currentBG; }
void CGMSensorInterface::simulateNextReading() { currentBG -= 0.5; }
void CGMSensorInterface::setBG(double newValue) { currentBG = newValue; }

// ===== File: ControlIQController.h =====
#ifndef CONTROLIQCONTROLLER_H
#define CONTROLIQCONTROLLER_H


class CGMSensorInterface;
class InsulinDeliveryManager;
class Profile;
/*
 * ControlIQController
 * -------------------
 * This class automatically adjusts insulin delivery based on CGM readings.
 * It supports the "Control IQ Automatic Adjustments" use case, including predicting
 * blood glucose trends and applying automatic corrections.
 */
class ControlIQController {
private:
    CGMSensorInterface* cgmSensor;
    InsulinDeliveryManager* deliveryManager;
    Profile* activeProfile;
    double predictedBG;
    bool isActive;

public:
    ControlIQController();
    ~ControlIQController();

    // Process a new sensor reading.
    void processSensorReading(double currentBG);
    // Predict future blood glucose trends.
    void predictBGTrend();
    // Apply automatic adjustments to insulin delivery.
    void applyAutomaticAdjustments();

    // Getters and setters.
    double getPredictedBG() const;
    void setPredictedBG(double bg);
    bool getIsActive() const;
    void setIsActive(bool active);
    void setInsulinDeliveryManager(InsulinDeliveryManager* mgr) { deliveryManager = mgr; }
    InsulinDeliveryManager* getInsulinDeliveryManager() const { return deliveryManager; }
    CGMSensorInterface* getCGMSensor() const;
    void setCGMSensor(CGMSensorInterface* sensor);
    void setDeliveryManager(InsulinDeliveryManager* manager);
};

#endif // CONTROLIQCONTROLLER_H

// ===== File: ControlIQController.cpp =====
#include "ControlIQController.h"
#include "CGMSensorInterface.h"
#include "InsulinDeliveryManager.h"
#include "Profile.h"
#include <iostream>
#include <cmath>

ControlIQController::ControlIQController()
    : cgmSensor(nullptr), predictedBG(0.0), isActive(false),
      deliveryManager(nullptr), activeProfile(nullptr) {}

ControlIQController::~ControlIQController() {}

void ControlIQController::processSensorReading(double currentBG) {
    predictedBG = currentBG;
    std::cout << "[ControlIQController] Received sensor reading: "
              << currentBG << " mmol/L\n";
}
void ControlIQController::predictBGTrend() {
    // If a CGM sensor is available, use its current reading and add a fixed offset
    // to simulate a 30-minute prediction. In a real system, this would be a more complex calculation.
    if (cgmSensor) {
        double current = cgmSensor->getCurrentBG();
        double predictionOffset = 1.0;  // Simulated increase by 1 mmol/L
        predictedBG = current + predictionOffset;
        std::cout << "[ControlIQController] Predicted BG in 30 minutes: "
                  << predictedBG << " mmol/L\n";
    } else {
        std::cout << "[ControlIQController] [Error] No CGM sensor available for prediction.\n";
    }
}

void ControlIQController::applyAutomaticAdjustments() {
    if (!deliveryManager) {
        std::cout << "[ControlIQController] [Error] Insulin Delivery Manager not set.\n";
        return;
    }

    if (predictedBG < 3.9) {
        std::cout << "[ControlIQController] Predicted BG (" << predictedBG
                  << " mmol/L) is very low. Stopping basal insulin delivery (Basal Suspended).\n";
        deliveryManager->stopBasalDelivery();
    }
    else if (predictedBG <= 6.25) {
        std::cout << "[ControlIQController] Predicted BG (" << predictedBG
                  << " mmol/L) is slightly low. Reducing basal insulin delivery.\n";
        if (deliveryManager->isBasalRunning()) {
            double currentRate = deliveryManager->getCurrentBasalRate();
            double newRate = currentRate * 0.8;  // reduce by 20%
            deliveryManager->startBasalDelivery(newRate);
        } else {
            std::cout << "[ControlIQController] Basal is not running; cannot reduce rate.\n";
        }
    }
    else if (predictedBG <= 8.9) {
        std::cout << "[ControlIQController] Predicted BG (" << predictedBG
                  << " mmol/L) is within the normal range. Continuing current basal rate.\n";
        // No adjustment needed.
    }
    else if (predictedBG < 10) {
        std::cout << "[ControlIQController] Predicted BG (" << predictedBG
                  << " mmol/L) is high. Increasing basal insulin delivery (up to max limit).\n";
        if (deliveryManager->isBasalRunning()) {
            double currentRate = deliveryManager->getCurrentBasalRate();
            double newRate = currentRate * 1.2;  // increase by 20%
            deliveryManager->startBasalDelivery(newRate);
        } else {
            std::cout << "[ControlIQController] Basal is not running; cannot increase rate.\n";
        }
    }
    else {
        std::cout << "[ControlIQController] Predicted BG (" << predictedBG
                  << " mmol/L) is very high. Delivering an automatic correction bolus.\n";
        double correctionDose = predictedBG - 7.0; // (this is a simple placeholder)
        deliveryManager->deliverBolus(correctionDose, false, 0.0);
    }
}

double ControlIQController::getPredictedBG() const { return predictedBG; }
void ControlIQController::setPredictedBG(double bg) { predictedBG = bg; }
bool ControlIQController::getIsActive() const { return isActive; }
void ControlIQController::setIsActive(bool active) { isActive = active; }
CGMSensorInterface* ControlIQController::getCGMSensor() const { return cgmSensor; }
void ControlIQController::setCGMSensor(CGMSensorInterface* sensor) { cgmSensor = sensor; }
void ControlIQController::setDeliveryManager(InsulinDeliveryManager* manager) { deliveryManager = manager; }

// ===== File: InsulinDeliveryManager.h =====
#ifndef INSULINDELIVERYMANAGER_H
#define INSULINDELIVERYMANAGER_H

#include <string>

class BolusCalculator;
class Battery;
class Cartridge;

class InsulinDeliveryManager {
private:
    double currentBasalRate;
    double insulinOnBoard;
    bool basalRunning;
    double previousBasalRate;
    BolusCalculator* bolusCalculator;
    Battery* battery;
    Cartridge* cartridge;

public:
    InsulinDeliveryManager();
    ~InsulinDeliveryManager();

    void startBasalDelivery(double rate);
    void stopBasalDelivery();
    void resumeBasalDelivery();
    void deliverBolus(double amount, bool extended, double duration);
    void updateIOB(double elapsedTime);
    bool hasSufficientInsulin(double requiredUnits);
    void onTick(double elapsedTime);

    double getCurrentBasalRate() const;
    void setCurrentBasalRate(double rate);
    double getInsulinOnBoard() const;
    void setInsulinOnBoard(double iob);
    bool isBasalRunning() const;
    void setBasalRunning(bool running);

    void setCartridge(Cartridge* cart) { cartridge = cart; }
    void setBolusCalculator(BolusCalculator* bc) { bolusCalculator = bc; }
    void setBattery(Battery* bat);
};

#endif // INSULINDELIVERYMANAGER_H

// ===== File: InsulinDeliveryManager.cpp =====
#include "InsulinDeliveryManager.h"
#include "BolusCalculator.h"
#include "Battery.h"
#include "Cartridge.h"
#include <iostream>

InsulinDeliveryManager::InsulinDeliveryManager()
    : currentBasalRate(0.0),
      insulinOnBoard(0.0),
      basalRunning(false),
      bolusCalculator(nullptr),
      battery(nullptr),
      cartridge(nullptr)
{
}

InsulinDeliveryManager::~InsulinDeliveryManager() {}

void InsulinDeliveryManager::startBasalDelivery(double rate) {
    if (!battery) {
        std::cout << "[InsulinDeliveryManager] [Error] No battery present. Cannot start basal.\n";
        return;
    }
    // Battery level check: ensure battery is not low (threshold: 20%)
    if (battery->getLevel() < 20) {
        std::cout << "[InsulinDeliveryManager] [Error] Battery level is low ("
                  << battery->getLevel() << "%). Cannot start basal.\n";
        return;
    }
    if (!cartridge) {
        std::cout << "[InsulinDeliveryManager] [Error] No cartridge present. Cannot start basal.\n";
        return;
    }
    // Print out the current insulin volume in the cartridge.
    std::cout << "[InsulinDeliveryManager] Cartridge volume: " << cartridge->getCurrentVolume() << " units.\n";
    if (cartridge->getCurrentVolume() < 1.0) {
        std::cout << "[InsulinDeliveryManager] [Error] Cartridge nearly empty. Basal not started.\n";
        return;
    }
    if (rate <= 0.0) {
        std::cout << "[InsulinDeliveryManager] [Error] Invalid basal rate: " << rate << " U/hr\n";
        return;
    }
    if (basalRunning) {
        std::cout << "[InsulinDeliveryManager] [Warning] Basal is already running at "
                  << currentBasalRate << " U/hr. Updating to " << rate << " U/hr.\n";
    }
    currentBasalRate = rate;
    basalRunning = true;
    std::cout << "[InsulinDeliveryManager] Basal started at " << rate << " U/hr\n";
}

void InsulinDeliveryManager::stopBasalDelivery() {
    basalRunning = false;
    std::cout << "[InsulinDeliveryManager] Basal stopped.\n";
}

void InsulinDeliveryManager::resumeBasalDelivery() {
    if (basalRunning) {
        std::cout << "[InsulinDeliveryManager] [Warning] Basal is already running. Cannot resume.\n";
        return;
    }
    if (currentBasalRate <= 0.0) {
        std::cout << "[InsulinDeliveryManager] [Error] No previous basal rate stored. Cannot resume basal.\n";
        return;
    }
    if (!battery) {
        std::cout << "[InsulinDeliveryManager] [Error] No battery present. Cannot resume basal.\n";
        return;
    }
    if (!cartridge) {
        std::cout << "[InsulinDeliveryManager] [Error] No cartridge present. Cannot resume basal.\n";
        return;
    }
    if (cartridge->getCurrentVolume() < 1.0) {
        std::cout << "[InsulinDeliveryManager] [Error] Cartridge nearly empty. Basal not resumed.\n";
        return;
    }
    basalRunning = true;
    std::cout << "[InsulinDeliveryManager] Basal resumed at " << currentBasalRate << " U/hr\n";
}


void InsulinDeliveryManager::deliverBolus(double amount, bool extended, double duration) {
    if (!cartridge) {
        std::cout << "[InsulinDeliveryManager] [Error] No cartridge present.\n";
        return;
    }
    if (cartridge->getCurrentVolume() < amount) {
        std::cout << "[InsulinDeliveryManager] [Error] Insufficient insulin. Bolus canceled.\n";
        return;
    }
    if (!cartridge->useInsulin(amount)) {
        std::cout << "[InsulinDeliveryManager] [Error] Cartridge usage failed. Bolus not delivered.\n";
        return;
    }
    if (!extended) {
        insulinOnBoard -= amount;
        std::cout << "[InsulinDeliveryManager] Delivered immediate bolus of " << amount << " units.\n";
    } else {
        if (!bolusCalculator) {
            std::cout << "[InsulinDeliveryManager] [Error] No BolusCalculator available. Extended bolus not delivered.\n";
            return;
        }
        double bolusSplit = bolusCalculator->calculateExtendedBolusSplit(amount, (duration/60.0));
        insulinOnBoard -= bolusSplit;
        std::cout << "[InsulinDeliveryManager] Delivering extended bolus of " << bolusSplit
                  << " units over the next " << duration << " hours.\n";
    }
}

void InsulinDeliveryManager::updateIOB(double elapsedTime) {
    double decayRate = 0.5; // 0.5 units/hr decay (placeholder)
    double reduceAmount = decayRate * elapsedTime;
    if (reduceAmount > insulinOnBoard) {
        insulinOnBoard = 0.0;
    } else {
        insulinOnBoard -= reduceAmount;
    }
}

bool InsulinDeliveryManager::hasSufficientInsulin(double requiredUnits) {
    if (!cartridge) return false;
    return (cartridge->getCurrentVolume() >= requiredUnits);
}

void InsulinDeliveryManager::onTick(double elapsedTime) {
    if (basalRunning) {
        double insulinRequired = currentBasalRate * (elapsedTime / 60.0);
        double availableInsulin = cartridge->getCurrentVolume();
        double insulinToDeliver = insulinRequired;

        if (availableInsulin < insulinRequired) {
            std::cout << "[InsulinDeliveryManager] [Warning] Insufficient insulin for full basal rate. Delivering partial dose: "
                      << availableInsulin << " units instead of " << insulinRequired << " units.\n";
            insulinToDeliver = availableInsulin;
        }

        if (cartridge->useInsulin(insulinToDeliver)) {
            insulinOnBoard += insulinToDeliver;
            std::cout << "[InsulinDeliveryManager] Delivered basal dose of " << insulinToDeliver << " units.\n";
        } else {
            std::cout << "[InsulinDeliveryManager] [Error] Failed to deliver basal dose.\n";
        }
    }

    updateIOB(elapsedTime);
}

double InsulinDeliveryManager::getCurrentBasalRate() const { return currentBasalRate; }
void InsulinDeliveryManager::setCurrentBasalRate(double rate) { currentBasalRate = rate; }
double InsulinDeliveryManager::getInsulinOnBoard() const { return insulinOnBoard; }
void InsulinDeliveryManager::setInsulinOnBoard(double iob) { insulinOnBoard = iob; }
bool InsulinDeliveryManager::isBasalRunning() const { return basalRunning; }
void InsulinDeliveryManager::setBasalRunning(bool running) { basalRunning = running; }
void InsulinDeliveryManager::setBattery(Battery* bat) { battery = bat; }

// ===== File: main.cpp =====
#include "PumpSimulator.h"
#include "ProfileManager.h"
#include "BolusCalculator.h"
#include "InsulinDeliveryManager.h"
#include "Cartridge.h"
#include "Battery.h"
#include "ControlIQController.h"
#include "CGMSensorInterface.h"

#include <iostream>
#include <string>
#include <thread>
#include <chrono>

int main() {
    PumpSimulator simulator;

    ProfileManager* pm = new ProfileManager();
    simulator.setProfileManager(pm);

    BolusCalculator* bc = new BolusCalculator();
    simulator.setBolusCalculator(bc);

    InsulinDeliveryManager* idm = new InsulinDeliveryManager();
    idm->setCartridge(new Cartridge());
    idm->setBattery(new Battery());
    idm->setBolusCalculator(new BolusCalculator());
    simulator.setInsulinDeliveryManager(idm);

    ControlIQController* ciq = new ControlIQController();
    CGMSensorInterface* cgmSensor = new CGMSensorInterface();
    ciq->setCGMSensor(cgmSensor);
    ciq->setIsActive(true);
    ciq->setDeliveryManager(idm);
    simulator.setControlIQController(ciq);

    simulator.startSimulation();

    std::thread updateThread([&simulator]() {
        while (simulator.getIsRunning()) {
            simulator.updateSimulationState();
            std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // 1-second tick
        }
    });

    std::string line;
    while (simulator.getIsRunning()) {
        std::cout << "\nEnter command: ";
        if (!std::getline(std::cin, line))
            break;
        if (line.empty())
            continue;
        simulator.handleUserInput(line);
    }

    if (updateThread.joinable()) {
        updateThread.join();
    }

    delete pm;
    delete bc;
    delete idm;
    delete ciq;

    return 0;
}
